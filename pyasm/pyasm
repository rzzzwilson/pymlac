#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
An assembler for the Imlac simulator.

Usage: pyasm [ -h ] [ -l <listfile> ] [ -o <outputfile> ] <asmfile>

Where <asmfile>  is the file to assemble,
      <outputfile>  is the output PTP file
      <listfile>    is the optional listing file

If <outputfile> is not specified the output filename is the input
<asmfile> with any extension removed and a .ptp axtenstion added.
"""

"""
The basic structure of the assembler:
0.  Read all file lines into memory
1.  Create ORG blocks
2.  Create CODE blocks from ORG blocks (assemble() function)
3.  Check for undefined things in the symbol table
4.  Allocate addresses to literal CODE blocks
5.  Fix relative addresses in literal blocks
6.  Backpatch all code blocks
7.  Emit PTP data
"""

import sys
import os
import copy
import string
import getopt

######
# Globals
######

# the input assembler filename
AsmFile = None

# the output listing file
ListFile = None
ListFileHandle = None       # open listing file

# the output PTP file
OutputFile = None
OutputFileHandle = None     # open output file

# the program start address (optional)
StartAddress = None

# the current address in assembled code (dot)
Address = None

# the symbol table(s)
# {<name>: <value>, ... }
SymTable = {}
# {<name>: <line#>, ... }
SymTableLine = {}

# the backpatch list
# [[symname, coderef, offset], [symname, coderef, offset], ... ]
BackpatchList = []

# current line number and the line
CurrentLine = None
CurrentLineNumber = None

# Any undefined label
Undefined = None

# buffer for blocked code
BlockMaxSize = 255
BlockBuffer = bytearray()
BlockBufferStart = None

######
# Mostly constant stuff
######

# mask for 16bit values
WordMask = 0xFFFF

# the output PTP filename extension
PTPExtension = '.ptp'

# the output listing filename extension
ListFileExtension = '.lst'

# length of a word in bits
WordBits = 16

# number of bytes in the 'zero' leader
ZeroLeaderSize = 32

# address states, AYES = address required,
#                 ANO  = address NOT required
#                 AOPT = address optional
(AYES, ANO, AOPT) = range(3)

######
# dict mapping opcode to generated word, address opts, address mask & indirect allowed
######

# helper function to generate N-bit mask, right justified
def mask(n):
    value = 0
    for _ in range(n):
        value = (value << 1) + 1

    return value

OpcodeData = {
              'LAW': ( 0004000, AYES, mask(11), False),
              'LWC': ( 0104000, AYES, mask(11), False),
              'JMP': ( 0010000, AYES, mask(11), True ),
              'DAC': ( 0020000, AYES, mask(11), True ),
              'XAM': ( 0024000, AYES, mask(11), True ),
              'ISZ': ( 0030000, AYES, mask(11), True ),
              'JMS': ( 0034000, AYES, mask(11), True ),
              'AND': ( 0044000, AYES, mask(11), True ),
              'IOR': ( 0050000, AYES, mask(11), True ),
              'XOR': ( 0054000, AYES, mask(11), True ),
              'LAC': ( 0060000, AYES, mask(11), True ),
              'ADD': ( 0064000, AYES, mask(11), True ),
              'SUB': ( 0070000, AYES, mask(11), True ),
              'SAM': ( 0074000, AYES, mask(11), True ),

              'HLT': ( 0000000, AOPT, mask(11), False),
              'NOP': ( 0100000, ANO,  0,        False),
              'CLA': ( 0100001, ANO,  0,        False),
              'CMA': ( 0100002, ANO,  0,        False),
              'STA': ( 0100003, ANO,  0,        False),
              'IAC': ( 0100004, ANO,  0,        False),
              'COA': ( 0100005, ANO,  0,        False),
              'CIA': ( 0100006, ANO,  0,        False),
              'CLL': ( 0100010, ANO,  0,        False),
              'CML': ( 0100020, ANO,  0,        False),
              'STL': ( 0100030, ANO,  0,        False),
              'ODA': ( 0100040, ANO,  0,        False),
              'LDA': ( 0100041, ANO,  0,        False),
              'CAL': ( 0100011, ANO,  0,        False),

              'RAL': ( 0003000, AYES, mask(2),  False),
              'RAR': ( 0003020, AYES, mask(2),  False),
              'SAL': ( 0003040, AYES, mask(2),  False),
              'SAR': ( 0003060, AYES, mask(2),  False),
              'DON': ( 0003100, ANO,  0,        False),

              'ASZ': ( 0002001, ANO,  0,        False),
              'ASN': ( 0102001, ANO,  0,        False),
              'ASP': ( 0002002, ANO,  0,        False),
              'ASM': ( 0102002, ANO,  0,        False),
              'LSZ': ( 0002004, ANO,  0,        False),
              'LSN': ( 0102004, ANO,  0,        False),
              'DSF': ( 0002010, ANO,  0,        False),
              'DSN': ( 0102010, ANO,  0,        False),
              'KSF': ( 0002020, ANO,  0,        False),
              'KSN': ( 0102020, ANO,  0,        False),
              'RSF': ( 0002040, ANO,  0,        False),
              'RSN': ( 0102040, ANO,  0,        False),
              'TSF': ( 0002100, ANO,  0,        False),
              'TSN': ( 0102100, ANO,  0,        False),
              'SSF': ( 0002200, ANO,  0,        False),
              'SSN': ( 0102200, ANO,  0,        False),
              'HSF': ( 0002400, ANO,  0,        False),
              'HSN': ( 0102400, ANO,  0,        False),

              'DLA': ( 0001003, ANO,  0,        False),
              'CTB': ( 0001011, ANO,  0,        False),
              'DOF': ( 0001012, ANO,  0,        False),
              'KRB': ( 0001021, ANO,  0,        False),
              'KCF': ( 0001022, ANO,  0,        False),
              'KRC': ( 0001023, ANO,  0,        False),
              'RRB': ( 0001031, ANO,  0,        False),
              'RCF': ( 0001032, ANO,  0,        False),
              'RRC': ( 0001033, ANO,  0,        False),
              'TPR': ( 0001041, ANO,  0,        False),
              'TCF': ( 0001042, ANO,  0,        False),
              'TPC': ( 0001043, ANO,  0,        False),
              'HRB': ( 0001051, ANO,  0,        False),
              'HOF': ( 0001052, ANO,  0,        False),
              'HON': ( 0001061, ANO,  0,        False),
              'STB': ( 0001062, ANO,  0,        False),
              'SCF': ( 0001071, ANO,  0,        False),
              'IOS': ( 0001072, ANO,  0,        False),

              'IOT': ( 0001000, AYES, mask(9),  False),
              'IOF': ( 0001161, ANO,  0,        False),
              'ION': ( 0001162, ANO,  0,        False),
              'PUN': ( 0001171, ANO,  0,        False),
              'PSF': ( 0001274, ANO,  0,        False),
              'PPC': ( 0001271, ANO,  0,        False),

              'DLXA': (0010000, AYES, mask(12), False),
              'DLYA': (0020000, AYES, mask(12), False),
#             'DEIM': (0030000, AYES, mask(12), False), # handled as pseudo-op
              'DJMS': (0050000, AYES, mask(12), False),
              'DJMP': (0060000, AYES, mask(12), False),

              'DOPR': (0004000, AYES, mask(4),  False),
              'DHLT': (0000000, ANO,  0,        False),
              'DSTS': (0004004, AYES, mask(2),  False),
              'DSTB': (0004010, AYES, mask(3),  False),
              'DRJM': (0004040, ANO,  0,        False),
              'DIXM': (0005000, ANO,  0,        False),
              'DIYM': (0004400, ANO,  0,        False),
              'DDXM': (0004200, ANO,  0,        False),
              'DDYM': (0004100, ANO,  0,        False),
              'DHVC': (0006000, ANO,  0,        False),
              'DDSP': (0004020, ANO,  0,        False),
              'DNOP': (0004000, ANO,  0,        False),
             }

######
# The papertape/teletype loader code
######

BlockLoader = [
#     code     address  assembler source code
#    -------   -------  ------------------------------------------------------------------------
              #        ; Imlac Papertape Program Block Loader
              #        ;
              #        ; This loader is loaded by the bootstrap program at x7700, where x=0 for
              #        ; a 4K machine, and x=1 for an 8K machine, etc.
              #        ;
              #        ; The load format consists of one or more contiguous blocks, with no
              #        ; padding bytes between them.  Each block has the form:
              #        ;
              #        ;          word count      (byte)
              #        ;          load address
              #        ;          data word 1
              #        ;          data word 2
              #        ;          ...
              #        ;          data word n
              #        ;          checksum
              #        ;
              #        ; All values are 16bit words, except the word count, which is an 8bit byte.
              #        ; Words are always received high-order byte first.
              #        ;
              #        ; After the word count there is the load address, followed by <word count>
              #        ; data words, which are loaded starting at "load address".
              #        ;
              #        ; The sum of all the data words in the block must be the same as the checksum
              #        ; word which follows the data words.  The checksum is calculated with 16bit
              #        ; integers, incrementing the sum whenever the 16bit value overflows.
              #        ;
              #        ; The end of the load is signalled by a block with a negative starting address.
              #        ;
              #        ; Disassembled from the 40tp_simpleDisplay.ptp image file.
              #        ;
              #                org     003700  ;
              #        cksum   equ     .-1     ;checksum stored here (before loader)
     0001032, # 003700         rcf             ;
     0013740, # 003701         jmp     patch   ;go decide TTY or PTR, clear AC
     0023677, # 003702 ndpatch dac     cksum   ;zero checksum, AC is zero (from patch)
     0037760, # 003703         jms     rdbyte  ;
     0102001, # 003704         asn             ;wait here for non-zero byte
     0013703, # 003705         jmp     .-2     ;
     0100006, # 003706         cia             ;
     0023777, # 003707         dac     wrdcnt  ;store negative word count
     0037750, # 003710         jms     rdword  ;read load address
     0023776, # 003711         dac     ldaddr  ;
     0077730, # 003712         sam     neg1    ;
     0013715, # 003713         jmp     rdblock ;
     0000000, # 003714         hlt             ;if load address is -1, halt - finished
     0037750, # 003715 rdblock jms     rdword  ;now read block to load address
     0123776, # 003716         dac     *ldaddr ;
     0037731, # 003717         jms     dosum   ;
     0033776, # 003720         isz     ldaddr  ;
     0033777, # 003721         isz     wrdcnt  ;
     0013715, # 003722         jmp     rdblock ;
     0037750, # 003723         jms     rdword  ;get expected checksum
     0073677, # 003724         sub     cksum   ;compare with calculated
     0102001, # 003725         asn             ;
     0013746, # 003726         jmp     newblk  ;if same, get next block
     0000000, # 003727         hlt             ;if not same, ERROR
     0177777, # 003730 neg1    data    0177777 ;
              #        ;------------------------
              #        ;Compute checksum.  Word to sum in AC.
              #        ;------------------------
     0017720, # 003731 dosum   bss     1       ;
     0100010, # 003732         cll             ;
     0067677, # 003733         add     cksum   ;
     0002004, # 003734         lsz             ;
     0100004, # 003735         iac             ;
     0023677, # 003736         dac     cksum   ;
     0113731, # 003737         jmp     *dosum  ;
              #        ;------------------------
              #        ;Decide what input device we are using, PTR or TTY.
              #        ;------------------------
     0001061, # 003740 patch   hon             ;
     0063774, # 003741         lac     ttyset  ;
     0023761, # 003742         dac     devpat  ;
     0005032, # 003743         law     1032    ;
     0177775, # 003744         sam     *adr044 ;
     0023761, # 003745         dac     devpat  ;
     0100011, # 003746 newblk  cal             ;
     0013702, # 003747         jmp     ndpatch ;
              #        ;------------------------
              #        ;Read WORD from input device.
              #        ;------------------------
     0017711, # 003750 rdword  bss     1       ;
     0100011, # 003751         cal             ;
     0037760, # 003752         jms     rdbyte  ;
     0003003, # 003753         ral     3       ;
     0003003, # 003754         ral     3       ;
     0003002, # 003755         ral     2       ;
     0037760, # 003756         jms     rdbyte  ;
     0113750, # 003757         jmp     *rdword ;
              #        ;------------------------
              #        ;Read BYTE from input device. Read from PTR or TTY.
              #        ;------------------------
     0017757, # 003760 rdbyte  bss     1       ;
     0001032, # 003761 devpat  rcf             ;could be patched to 'jmp rdtty'
     0102400, # 003762         hsn             ;
     0013762, # 003763         jmp     .-1     ;
     0002400, # 003764         hsf             ;
     0013764, # 003765         jmp     .-1     ;
     0001051, # 003766         hrb             ;read PTR byte
     0113760, # 003767         jmp     *rdbyte ;
     0002040, # 003770 rdtty   rsf             ;
     0013770, # 003771         jmp     .-1     ;
     0001033, # 003772         rrc             ;read TTY byte, clear flag
     0113760, # 003773         jmp     *rdbyte ;
              #        ;------------------------
     0013770, # 003774 ttyset  jmp     rdtty   ;
     0000044, # 003775 adr044  data    044     ;
     0000000, # 003776 ldaddr  data    0       ;
     0000000, # 003777 wrdcnt  data    0       ;
              #        ;------------------------
              #                end             ;
              ]


def usage(msg=None):
    """Print usage and optional error message."""
    if msg:
        print('*'*60)
        print(msg)
        print('*'*60)
    print(__doc__)

def error(msg):
    """Print a syntax error and abort."""

    lnum = CurrentLineNumber if CurrentLineNumber else 1
    line = CurrentLine if CurrentLine else ''

    print('-' * 80)
    print("%04d: %s" % (lnum, line))
    print(msg)
    print('-' * 80)

    sys.exit(10)

def write_byte(byte):
    """Write one byte into the output code file.

    Write only the low 8 bits of 'byte'.
    """

    print('write_byte: byte=%04o' % byte)
    OutputFileHandle.write(chr(byte & 0xFF))

def write_word(word):
    """Emit a 16-bit word to the output file."""

    write_byte(word >> 8)
    write_byte(word)

def write_start(address):
    """Write the start block."""

    write_block()        # emit any code accumulated
    start_block(address)
    write_block()

def write_leader():
    """Write the papertape leader."""

    for _ in range(ZeroLeaderSize):
        write_byte(0)

def write_block_loader():
    """Emit the block loader prefix code."""

    write_leader()

    for word in BlockLoader:
        write_word(word)

    write_leader()

def start_block(addr):
    """Prepare next block to start at 'addr'"""

    global BlockBuffer, BlockBufferStart

    BlockBuffer = []
    BlockBufferStart = addr
    print('start_block: BlockBufferStart set to %s' % str(BlockBufferStart))

def emit_word(word):
    """Put a word into the code block buffer.

    Write buffer out if full.
    """

    code_block_size = len(BlockBuffer)
    if code_block_size >= BlockMaxSize:
        write_block()
        start_block(Dot)

    BlockBuffer.append(word)

def write_block():
    """Write the current code block and reset the buffer."""

    global BlockBuffer, BlockBufferStart

    code_block_size = len(BlockBuffer)
    print('write_block: code_block_size=%d, BlockBufferStart=%s'
          % (code_block_size, str(BlockBufferStart)))
    if code_block_size == 0:
        # block buffer is empty, do nothing
        return

    # emit the block size and load address
    write_byte(code_block_size)
    write_word(BlockBufferStart)
    for word in BlockBuffer:
        write_word(word)

    # calculate checksum
    checksum = 0
    for word in BlockBuffer:
        checksum += word
        if checksum and ~WordMask:
            ++checksum
        checksum &= WordMask
        write_word(word)

    # emit the block checksum
    write_word(checksum)

    # reset the code buffer
    BlockBuffer = []
    BlockBufferStart = None

def write_list(code, addr, lnum, line):
    """Generate one line of listing file.

    code  is the word of generated code
    addr  is the address of the generated code
    lnum  file line number
    line  complete text of the line of assembler
    """

    code_str = '%06o' % code if code else ''
    addr_str = '%04o' % addr if addr else ''
    lnum_str = '%04d:' % lnum if lnum else ''
    line_str = '%s' % line if line else ''

    ListFileHandle.write('%6s %4s %s %s\n'
                         % (code_str, addr_str, lnum_str, line_str))
    ListFileHandle.flush()

def eval_expr(expr):
    """Evaluate a expression string.

    expr  string holding expression

    Returns 'None' if there is no valid expression.
    """

    global Undefined

    # if no expression, do nothing
    if expr is None:
        return None

    # replace any "." value with "dot" defined in the symbol table
    expr = string.replace(expr, '.', 'DOT')
    globs = copy.deepcopy(SymTable)
    globs['DOT'] = Dot       # add in the "." address

    # evaluate the expression
    try:
        result = eval(expr, globs)
#    except TypeError as e:
#        error("ORG pseudo-opcode expression contains unsatisfied references")
#        return None
    except (TypeError, NameError) as e:
        Undefined = e.message
        if 'is not defined' in e.message:
            Undefined = e.message[len("name '"):-len("' is not defined")]
            raise NameError("ORG pseudo-opcode expression has '%s' undefined" % Undefined)
#            error("ORG pseudo-opcode expression has '%s' undefined" % Undefined)
        raise NameError("ORG pseudo-opcode expression has an error")
#        error("ORG pseudo-opcode expression has an error")

    return result

def num_gen_words(opcode, addr):
    """Calculate number of words generated by this opcode."""

    if opcode:
        # we assume opcode will return 1
        return 1

    return 0

def pass_1(lines):
    """Do pass 1 of the assembly.

    lines  lines of text with terminal EOL removed

    Just read text and fill in the symbol table.
    Returns False if there was an error.
    """

    global Dot, StartAddress
    global CurrentLineNumber, CurrentLine
    global SymTable, SymTableLine

    # initialize things
    Dot = None
    Symtable = {}
    SymTableLine = {}

    # for each line in the file
    for (lnum, line) in enumerate(lines):
        lnum += 1           # line numbers are 1-based
        CurrentLineNumber = lnum
        CurrentLine = line

        # get line fields
        (label, opcode, indirect, addr) = split_fields(line)

        if opcode:
            # we have an opcode, so code might be generated
            if opcode == 'ORG':
                if not addr or eval_expr(addr) is None:
                    error("ORG pseudo-op has a bad address")
                    return False
                Dot = eval_expr(addr)
                if label:
                    error("ORG pseudo-op must not have a label")

            elif opcode == 'EQU':
                # no code, but we define a label
                if not label:
                    error("EQU pseudo-op must have a label")
                    return False
                if not addr or eval_expr(addr) is None:
                    error("EQU pseudo-op has a bad value")
                    return False
                define_label(label, eval_expr(addr), lnum)

            elif opcode == 'BSS':
                # no code, but Dot moves
                if not addr or eval_expr(addr) is None:
                    error("BSS pseudo-op has a bad value")
                    return False
                if label:
                    define_label(label, Dot, lnum)
                Dot += eval_expr(addr)

            elif opcode == 'DATA':
                # a single data word
                if not addr or eval_expr(addr) is None:
                    error("BSS pseudo-op has a bad value")
                    return False
                if label:
                    define_label(label, Dot, lnum)
                Dot += 1

            elif opcode == 'ASCII':
                # ASCII string, pack two bytes/word, maybe zero byte fill at end
                print('ASCII: addr=%' % str(addr))
        # TODO worry if string has delimiting quotes
                ascii_len = len(addr)
                ascii_words = ascii_len / 2
                if ascii_len % 2:
                    ascii_words += 1
                Dot += ascii_words

            elif opcode == 'END':
                # get the (optional) start address
                StartAddress = None
                if addr:
                    StartAddress = eval_expr(addr)
                    if StartAddress is None:
                        error("END pseudo-op has a bad address")
                        return False
                return True

            else:
                # actual machine instruction!
                if label:
                    define_label(label, Dot, lnum)
                Dot += num_gen_words(opcode, addr);

        elif label:
            # label but no code generated, just set label in symtab
            if label in SymTable:
                error("Label '%s' has already been defined" % label)
                return False
            define_label(label, Dot, lnum)

    return True

def pass_2(lines):
    """Perform the second pass of the assembly.

    Very similar to pass_1(), but we:
        . don't define labels, that was done in pass_1()
        . check that any pass_2 labels haven't changed value
    """

    global Dot, StartAddress, CurrentLineNumber, CurrentLine

    # punch the zero leader and ptr/tty loader
    write_block_loader()

    # for each line in the file
    Dot = None
    for (lnum, line) in enumerate(lines):
        lnum += 1           # line numbers are 1-based
        CurrentLineNumber = lnum
        CurrentLine = line

        # get line fields
        (label, opcode, indirect, addr) = split_fields(line)
        print('pass_2: label=%s, opcode=%s, indirect=%s, addr=%s'
              % (str(label), str(opcode), str(indirect), str(addr)))

        if opcode:
            # we have an opcode, so code might be generated
            if opcode == 'ORG':
                if label:
                    error("ORG pseudo-op may not have a label")
                    return False
                if not addr or eval_expr(addr) is None:
                    error("ORG pseudo-op has a bad address")
                    return False
                write_block()        # write any code accumulated so far
                Dot = eval_expr(addr)
                print('ORG: Dot set to %06o' % Dot)
                start_block(Dot)

            elif opcode == 'EQU':
                # no code, but we must have a label
                if not label:
                    error("EQU pseudo-op must have a label")
                    return False
                if not addr or eval_expr(addr) is None:
                    error("EQU pseudo-op has a bad value")
                    return False
                value = eval_expr(addr)
                # check EQU value unchanged
                try:
                    old_value = SymTable[label]
                    if value != old_value:
                        error("EQU value in '%s' has changed,\n"
                              "was %06o, is now %06o"
                              % (old_value, value))
                except KeyError:
                    error("EQU label '%s' wasn't defined in first pass!?"
                          % label)
            elif opcode == 'BSS':
                # no code, but Dot moves
                if not addr or eval_expr(addr) is None:
                    error("BSS pseudo-op has bad value")
                    return False
                value = eval_expr(addr)
                if label:
                    try:
                        old_value = SymTable[label]
                        if value != old_value:
                            error("BSS value in has changed, "
                                  "was %06o, is now %06o"
                                  % (old_value, value))
                    except KeyError:
                        error("BSS label '%s' wasn't defined in first pass!?"
                              % label)
                write_block()        # write any code accumulated so far
                Dot += value
                start_block(Dot)

            elif opcode == 'DATA':
                # a single data word
                if not addr or eval_expr(addr) is None:
                    error("BSS pseudo-op has bad value")
                    return False
                value = eval_expr(addr)
                if label:
                    try:
                        old_value = SymTable[label]
                        if value != old_value:
                            error("BSS value has changed, "
                                  "was %06o, is now %06o"
                                  % (old_value, value))
                    except KeyError:
                        error("DATA label '%s' wasn't defined in first pass!?"
                              % label)
                emit_word(value)
                Dot += 1

            elif opcode == 'ASCII':
                len_addr = len(addr)
                for i in range(0, len_addr-1, 2):
                    emit_word(ord((addr[i]) << 8) + ord(addr[i+1]))
                    Dot += 1
                if len_addr % 2:
                    emit_word((ord(addr[-1]) << 8))
                    Dot += 1

            elif opcode == 'END':
                # get optional start address
                StartAddress = None
                if addr:
                    # we have the optional start address
                    start_address = eval_expr(addr)
                    if start_address != StartAddress:
                        error("Pass 2 start address is different from pass 1, "
                              "was %06o but now %06o"
                              % (StartAddress, start_address))
                    StartAddress = start_address
                break       # end of pass
            else:
                # actual machine instruction!
                # if label, check value unchanged
                if label:
                    if not label in SymTable:
                        error("Label '%s' not defined in pass 1!?" % label)
                    old_dot = SymTable[label]
                    if old_dot != Dot:
                        error("Start address has different value in pass 2.\n"
                              "Was %06o, now %06o"
                              % (old_dot, Dot))
                gen_code(lnum, line, label, label, opcode, indirect, addr)
                Dot += 1

        elif label:
            # label but no code generated, just check Dot for label unchanged
            if label in SymTable:
                dot = SymTable[label]
                if dot != Dot:
                    error("Label '%s' has value %06o, was %06o in first pass"
                          % (label, Dot, dot))

    # write the final block of code and optional start address
    write_block()
    if StartAddress is not None:
        print('write_start(%06o)' % StartAddress)
        write_start(StartAddress)
    write_leader()

    # check nothing after END
    if lnum - 1 > len(lines):
        error("Something after the 'END' pseudo-op!?")

def gen_code(lnum, line, dot, label, opcode, indirect, addr):
    """Assemble one line of code.

    lnum      source file line number
    line      the actual source line (for error reporting)
    dot       current address in the assembly
    label     optional label
    opcode    opcode, uppercase
    indirect  True if indirect flag found
    addr      address expression, uppercase

    Puts the assembled word into the punch buffer.
    """

    print('gen_code: lnum=%d, line=%s, label=%s, opcode=%s, addr=%s'
          % (lnum, line, str(label), str(opcode), str(addr)))

    # get instruction coding details
    try:
        (word, aok, mask, ind) = OpcodeData[opcode]
    except KeyError:
        error("%d: %s\nUnrecognized opcode '%s'" % (lnum, line, opcode))
    print('word=%06o, aok=%d, mask=%06o, ind=%s' % (word, aok, mask, str(ind)))

    value = eval_expr(addr)
    if aok in (AYES, AOPT):
        print('addr=%s, value=%s' % (str(addr), str(value)))

    word_s = format(word, '016b')
    mask_s = format(mask, '016b') if mask else ''
    value_s = format(value, '016b') if value else ''

    print('word=%s, mask=%s, ind=%s, value=%s' % (word_s, mask_s, str(ind), value_s))

    # check if 'addr' has overflowed.  add in if OK
    if value:
        if value & mask != value:
            error("Address field overflow: %06o" % value)
        word += value

    # if indirect and indirect OK, set high bit
    if indirect and ind:
        word += 0100000
    if not ind and indirect:
        error("Indirect not allowed here")

    emit_word(word)

def define_label(label, address, lnum):
    """Put 'label' into the symbol tables.

    label    the label to define
    address  dot value for he label
    lnum     ine number the label is defined on

    It's an error if the label is already defined.
    """

    if label in SymTable:
        prev_lnum = SymTableLine[label]
        error("Label '%s' defined twice, at lines %d and %d."
              % (label, prev_lnum, lnum))
    SymTable[label] = address
    SymTableLine[label] = lnum

def gen_ascii(string, address, lnum, line):
    """Generate data words for ASCII string.

    string   the string to generate data for
    address  addres of first generated word (dot)
    lnum     line number of code
    line     actual line of code

    Returns the updated 'dot' value.
    """

    # ensure even number of bytes in string
    if len(string) % 2:
        string += '\0'      # append zero byte as padding

    # get 2 bytes at a time and generate words
    while string:
        ch1 = string[0]
        ch2 = string[1]
        string = string[2:]
        value = (ord(ch1) << 8) + ord(ch2)
        write_list(value, address, lnum, line)
        address += 1
        lnum = None
        line = None

    return address

def next_symbol(line):
    """Return next symbol and line remainder."""

    fields = string.split(line, maxsplit=1)
    if len(fields) != 2:
        fields.append('')

    return fields

def split_fields(line):
    """Split one ASM line into fields: label, opcode, indirect, address.

    Returns a tuple: (label, opcode, indirect, address).
    If label and opcode are not None, uppercase the result string.
    If address is not None and is not a string, it's uppercased.
    'indirect' is either True or False.

    If a field is missing, return None for it.  If the line is empty, return
    (None, None, False, None).

    We take pains not to split the address field if it's something like
        ALPHA + 100
    """

    if not line:
        return (None, None, False, None)

    # check for the label
    label = None
    if line[0] not in ' \t;':
        (label, remainder) = next_symbol(line)
        label = label.upper()
    else:
        remainder = line.strip()

    # get opcode
    opcode = None
    if remainder and remainder[0] != ';':
        (opcode, remainder) = next_symbol(remainder)
        opcode = opcode.upper()

    # get address
    indirect = False
    address = None
    if remainder and remainder[0] != ';':
        if remainder[0] in "'\"":
            # it's a string
            delim = remainder[0]
            remainder = remainder[1:]
            ndx = remainder.find(delim)
            if ndx == -1:
                error('Unbalanced string delimiter:\n'
                      '%d: %s' % (CurrentLineNumber, CurrentLine))
            address = '"' + remainder[:ndx].strip() + '"'
            remainder = remainder[ndx+1:].strip()
        else:
            # otherwise just an expression, strip off any indirect
            ndx = remainder.find(';')
            if ndx != -1:
                remainder = remainder[:ndx].strip()
            if remainder[0] == '*':
                indirect = True
                remainder = remainder[1:]
            address = remainder.strip().upper()
            remainder = None

    # check that remainder is empty or only a comment
    if remainder and remainder[0] != ';':
        error('Badly formed instruction:\n'
              '%d: %s' % (CurrentLineNumber, CurrentLine))

    return (label, opcode, indirect, address)

def assemble_file():
    """Assemble the file and produce listing & output files."""

    # read all of ASM file into memory, strip \n, etc
    with open(AsmFile, 'rb') as fd:
        asm_lines = fd.readlines()
    asm_lines = [line.rstrip() for line in asm_lines]
    print('asm_lines=\n%s' % '\n'.join(asm_lines))

    if pass_1(asm_lines):
        print('After pass_1(), SymTable=%s' % str(SymTable))
        pass_2(asm_lines)
        print('After pass_2(), SymTable=%s' % str(SymTable))

def main():
    """The assembler."""

    global AsmFile, ListFile, OutputFile
    global ListFileHandle, OutputFileHandle

    # handle the options
    try:
        (opts, args) = getopt.gnu_getopt(sys.argv, "hl:o:",
                                         ["help", "list=", "output="])
    except getopt.GetoptError:
        usage()
        sys.exit(10)

    ListFile = None
    OutputFile = None

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif opt in ('-l', '--list'):
            ListFile = arg
        elif opt in ('-o', '--output'):
            OutputFile = arg

    if len(args) != 2:
        usage()
        sys.exit(10)

    # get ASM filename and make sure it exists
    AsmFile = args[1]
    try:
        f = open(AsmFile, 'rb')
    except IOError:
        print("Sorry, can't find file '%s'" % AsmFile)
        sys.exit(10)
    f.close()

    if OutputFile is None:
        (path, ext) = os.path.splitext(AsmFile)
        OutputFile = path + PTPExtension
    OutputFileHandle = open(OutputFile, 'wb')

    if ListFile is None:
        (path, ext) = os.path.splitext(AsmFile)
        ListFile = path + ListFileExtension
    ListFileHandle = open(ListFile, 'wb')

    print('ListFile=%s, OutputFile=%s, AsmFile=%s'
          % (str(ListFile), str(OutputFile), str(AsmFile)))

    assemble_file()

if __name__ == '__main__':
    main()


#/******************************************************************************
#       Name : emitblock()
#Description : Emit the code for the current block.
# Parameters :
#    Returns :
#   Comments :
# *****************************************************************************/
#static void
#emitblock(void)
#{
#    if (nextcodeword > 0)
#    {
#        WORD checksum;
#        int  i;
#
#    /******
#     * Emit block header stuff.
#     ******/
#
#        emitbyte(nextcodeword);
#        emitword(codeblockstart);
#
#    /******
#     * Calculate the checksum while we emit code.
#     ******/
#
#        checksum = 0;
#
#        for (i = 0; i < nextcodeword; ++i)
#        {
#            checksum = checksum + codeblock[i];
#            if (checksum & ~WORDMASK)
#                ++checksum;
#            checksum &= WORDMASK;
#            emitword(codeblock[i]);
#        }
#
#    /******
#     * Emit bchecksum.
#     ******/
#
#        emitword(checksum);
#    }
#}
#
#
#/******************************************************************************
#       Name : emitcode()
#Description : Generate code for one word.
# Parameters : code - the WORD to put into current code block
#    Returns :
#   Comments : If the block buffer is full, spill to the output file first.
# ******************************************************************************/
#static void
#emitcode(WORD code)
#{
#    if (dot == -1L)
#        synerror(inputline, "Expected ORG pseudo-op");
#
#    /* if current block is full, emit and reset */
#    if (nextcodeword >= MAXBLOCKSIZE)
#    {
#        emitblock();
#
#        codeblockstart = dot;
#        nextcodeword = 0;
#    }
#
#    codeblock[nextcodeword++] = code;
#}
#
#
#/******************************************************************************
#       Name : geninc()
#Description : Generate code for one word of INC code.
# Parameters : field  - INC field to generate code for
#    Returns : The code word generated.
#   Comments :
# ******************************************************************************/
#static WORD
#geninc(char *field)
#{
#    char *endfld;
#    WORD highbyte;
#    WORD lowbyte;
#
#    if (field == NULL)
#        synerror(inputline, "Data field required on INC statement");
#
#    endfld = strchr(field, ',');
#    if (endfld == NULL)
#        synerror(inputline, "Bad data field on INC statement");
#    *endfld = '\0';
#    ++endfld;
#
#    highbyte = genincbyte(field);
#    lowbyte = genincbyte(endfld);
#
#    return (highbyte << 8) | lowbyte;
#}
#
#
#/******************************************************************************
#       Name : genincbyte()
#Description : Generate code for one byte of INC code.
# Parameters : infile - input filename (error reporting)
#            : lnum   - input line number (error reporting)
#            : field  - INC byte field to generate code for
#    Returns :
#   Comments :
# ******************************************************************************/
#static WORD
#genincbyte(char *field)
#{
#    static int  beam = 1;
#
#    int  x;
#    int  y;
#    int  xneg = 0;
#    int  yneg = 0;
#
#    switch (toupper(*field))
#    {
#        case 'A':    /* make byte */
#            ++field;
#            if (isoctal(field))
#                return atoo(field);
#            else if (isdecimal(field))
#                return atoi(field);
#            else
#                synerror(inputline, "Bad INC 'A' field");
#            break;
#        case 'B':        /* beam on */
#            beam = 1;
#            ++field;
#            break;
#        case 'D':        /* beam off */
#            beam = 0;
#            ++field;
#            break;
#        case 'E':        /* enter INC mode */
#/*            beam = 1; UNUSED */
#            return 0060;
#            break;
#        case 'F':        /* escape INC mode */
#            return 0171;
#            break;
#        case 'N':
#            return 0111;
#            break;
#        case 'P':        /* pause (filler) */
#            return 0200;
#            break;
#        case 'R':
#            return 0151;
#            break;
#        case 'X':
#            return 0010;
#            break;
#        case 'Y':
#            return 0001;
#            break;
#        case '+': case '-': case '0': case '1': case '2': case '3':
#            break;
#        default:
#            synerror(inputline, "Bad INC field");
#            break;
#    }
#
#    if (*field == '+')
#    {
#        xneg = 0;
#        ++field;
#    }
#    else if (*field == '-')
#    {
#        xneg = 1;
#        ++field;
#    }
#
#    if (strchr("0123", *field) == NULL)
#        synerror(inputline, "Bad INC field");
#
#    x = *field - '0';
#    ++field;
#
#    if (*field == '+')
#    {
#        yneg = 0;
#        ++field;
#    }
#    else if (*field == '-')
#    {
#        yneg = 1;
#        ++field;
#    }
#
#    if (strchr("0123", *field) == NULL)
#        synerror(inputline, "Bad INC field");
#
#    y = *field - '0';
#    ++field;
#
#    if (strlen(field) != 0)
#        synerror(inputline, "Bad INC field");
#
#    return 0200 | (beam << 6) | (xneg << 5) | (x << 3) | (yneg << 2) | y;
#}
#
#
#
